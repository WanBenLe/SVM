#install.packages("pso")
#安装PSO的包,去掉开头的#号,#和MATLAB中的%一样都是注释,算法论文到处都是很简单
timestart<-Sys.time()
#获取系统运行时间
library(pso)
#调用PSO包
D_0<-c(-200,-400,150)/1000
#c是向量的标志
C_0<-c(200,-450,155)/1000
S_0<-c(0,-750,100)/1000
P_0<-c(0,-600,150)/1000
J_0<-c(40,-500,650)/1000
H_0<-c(200,-400,300)/1000
I_0<-c(150,750,300)/1000
B_0<-c(100,-450,525)/1000
N_0<-c(250,-490,530)/1000
E_0<-c(40,-675,525)/1000
L_0<-c(0,-800,300)/1000
R_NB<-B_0-N_0
R_BE<-E_0-B_0
R_CD<-D_0-C_0
R_DS<-S_0-D_0
R_SE<-E_0-S_0
R_IE<-E_0-I_0
R_HI<-I_0-H_0
R_JP<-P_0-J_0
R_SL<-L_0-S_0
R_SI<-I_0-S_0
R_DP<-P_0-D_0
f1<-rep(0,3)
f2<-rep(0,3)
f3<-rep(0,3)
f5<-rep(0,3)
f6<-rep(0,3)
f7<-rep(0,3)
#rep(x,y)创建一个向量(x,x,x,x)有y个
fun.cross<- function(a,b){
c<-c(a[2]*b[3]-b[2]*a[3],a[3]*b[1]-b[3]*a[1],a[1]*b[2]-b[1]*a[2])
return(c)
}
#MATLAB的cross的实现,下面是需要优化的函数了
x<-function(x){
av1_temp<-x[1]*R_NB
VE<-fun.cross(av1_temp,R_BE)
#调用上面的cross函数
av2_temp<-x[2]*R_CD
av3_temp<-c(x[3],x[4],x[5])
av4_temp<-c(x[6],x[7],x[8])
VS<-fun.cross(av2_temp,R_DS)
VSE<-fun.cross(av3_temp,R_SE)
VSI<-fun.cross(av3_temp,R_SI)
VI<-fun.cross(av4_temp,R_HI)
VIE<-fun.cross(av3_temp,R_IE)
VL<-c(x[9],x[10],x[11])
VSL<-fun.cross(av3_temp,R_SL)
AL<-c(x[12],0.247339866917719,1.30994155089154)
aa1_temp<-x[13]*R_NB
aa2_temp<-x[14]*R_CD
aa3_temp<-c(x[15],x[16],x[17])
aa4_temp<-c(x[18],x[19],x[20])
AE<-fun.cross(av1_temp,VE)+fun.cross(aa1_temp,R_BE)
AS<-fun.cross(av2_temp,VS)+fun.cross(aa2_temp,R_DS)
ASE<-fun.cross(av3_temp,VSE)+fun.cross(aa3_temp,R_SE)
ASI<-fun.cross(av3_temp,VSI)+fun.cross(aa3_temp,R_SI)
AI<-fun.cross(av4_temp,VI)+fun.cross(aa4_temp,R_HI)
ASL<-fun.cross(av3_temp,VSL)+fun.cross(aa3_temp,R_SL)
f1[1]<-VE[1]-VS[1]-VSE[1]
f1[2]<-VE[2]-VS[2]-VSE[2]
f1[3]<-VE[3]-VS[3]-VSE[3]
f2[1]<-VE[1]-VI[1]-VIE[1]
f2[2]<-VE[2]-VI[2]-VIE[2]
f2[3]<-VE[3]-VI[3]-VIE[3]
f3[1]<-VL[1]-VS[1]-VSL[1]
f3[2]<-VL[2]-VS[2]-VSL[2]
f3[3]<-VL[3]-VS[3]-VSL[3]
f5[1]<-AE[1]-AS[1]-ASE[1]
f5[2]<-AE[2]-AS[2]-ASE[2]
f5[3]<-AE[3]-AS[3]-ASE[3]
f6[1]<-AI[1]-AS[1]-ASI[1]
f6[2]<-AI[2]-AS[2]-ASI[2]
f6[3]<-AI[3]-AS[3]-ASI[3]
f7[1]<-AL[1]-AS[1]-ASL[1]
f7[2]<-AL[2]-AS[2]-ASL[2]
f7[3]<-AL[3]-AS[3]-ASL[3]
f4<-av4_temp%*%R_HI
f8<-aa4_temp%*%R_HI
#求内积,就是点乘
fxxx<-(((f1[1])^2+(f1[2])^2+(f1[3])^2+(f2[1])^2+(f2[2])^2+(f2[3])^2+(f3[1])^2+(f3[2])^2+(f3[3])^2+(f4)^2+(f5[1])^2+(f5[2])^2+(f5[3])^2+(f6[1])^2+(f6[2])^2+(f6[3])^2+(f7[1])^2+(f7[2])^2+(f7[3])^2+(f8)^2)^.5)/20
#因为是最小化误差平方和,所以就用了(SSE^.5)/20
return(fxxx)
#返回fxxx就成为了单目标优化了
}
a<-psoptim(rep(NA,20),x,lower=-100,upper=100,control=list(abstol=1e-8,maxit=13500,p=0.95))
#PSO算法调用,20个无初值的变量(x[1-20]),x函数,上下限是+-100,结束迭代条件为10^-8,最大迭代13500次,信息交换百分比0.95,其它基于传统算法选择
a
#输出结果,a$par是系数
timeend<-Sys.time()
runningtime<-timeend-timestart
print(runningtime)
#输出运行时间